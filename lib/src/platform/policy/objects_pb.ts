// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file policy/objects.proto (package policy, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { BoolValue, Message, proto3 } from '@bufbuild/protobuf';
import { Metadata } from '../common/common_pb.js';

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.AttributeRuleTypeEnum
 */
export enum AttributeRuleTypeEnum {
  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF = 1;
   */
  ALL_OF = 1,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF = 2;
   */
  ANY_OF = 2,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY = 3;
   */
  HIERARCHY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AttributeRuleTypeEnum)
proto3.util.setEnumType(AttributeRuleTypeEnum, 'policy.AttributeRuleTypeEnum', [
  { no: 0, name: 'ATTRIBUTE_RULE_TYPE_ENUM_UNSPECIFIED' },
  { no: 1, name: 'ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF' },
  { no: 2, name: 'ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF' },
  { no: 3, name: 'ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY' },
]);

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.SubjectMappingOperatorEnum
 */
export enum SubjectMappingOperatorEnum {
  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_IN = 1;
   */
  IN = 1,

  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_NOT_IN = 2;
   */
  NOT_IN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SubjectMappingOperatorEnum)
proto3.util.setEnumType(SubjectMappingOperatorEnum, 'policy.SubjectMappingOperatorEnum', [
  { no: 0, name: 'SUBJECT_MAPPING_OPERATOR_ENUM_UNSPECIFIED' },
  { no: 1, name: 'SUBJECT_MAPPING_OPERATOR_ENUM_IN' },
  { no: 2, name: 'SUBJECT_MAPPING_OPERATOR_ENUM_NOT_IN' },
]);

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.ConditionBooleanTypeEnum
 */
export enum ConditionBooleanTypeEnum {
  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_AND = 1;
   */
  AND = 1,

  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_OR = 2;
   */
  OR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConditionBooleanTypeEnum)
proto3.util.setEnumType(ConditionBooleanTypeEnum, 'policy.ConditionBooleanTypeEnum', [
  { no: 0, name: 'CONDITION_BOOLEAN_TYPE_ENUM_UNSPECIFIED' },
  { no: 1, name: 'CONDITION_BOOLEAN_TYPE_ENUM_AND' },
  { no: 2, name: 'CONDITION_BOOLEAN_TYPE_ENUM_OR' },
]);

/**
 * @generated from message policy.Namespace
 */
export class Namespace extends Message<Namespace> {
  /**
   * generated uuid in database
   *
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * used to partition Attribute Definitions, support by namespace AuthN and enable federation
   *
   * @generated from field: string name = 2;
   */
  name = '';

  /**
   * @generated from field: string fqn = 3;
   */
  fqn = '';

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 4;
   */
  active?: boolean;

  /**
   * @generated from field: common.Metadata metadata = 5;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Namespace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.Namespace';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'fqn', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'active', kind: 'message', T: BoolValue },
    { no: 5, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Namespace {
    return new Namespace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJsonString(jsonString, options);
  }

  static equals(
    a: Namespace | PlainMessage<Namespace> | undefined,
    b: Namespace | PlainMessage<Namespace> | undefined
  ): boolean {
    return proto3.util.equals(Namespace, a, b);
  }
}

/**
 * @generated from message policy.Attribute
 */
export class Attribute extends Message<Attribute> {
  /**
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * namespace of the attribute
   *
   * @generated from field: policy.Namespace namespace = 2;
   */
  namespace?: Namespace;

  /**
   * attribute name
   *
   * @generated from field: string name = 3;
   */
  name = '';

  /**
   * attribute rule enum
   *
   * @generated from field: policy.AttributeRuleTypeEnum rule = 4;
   */
  rule = AttributeRuleTypeEnum.UNSPECIFIED;

  /**
   * @generated from field: repeated policy.Value values = 5;
   */
  values: Value[] = [];

  /**
   * @generated from field: repeated policy.KeyAccessServer grants = 6;
   */
  grants: KeyAccessServer[] = [];

  /**
   * @generated from field: string fqn = 7;
   */
  fqn = '';

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 8;
   */
  active?: boolean;

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Attribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.Attribute';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'namespace', kind: 'message', T: Namespace },
    { no: 3, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'rule', kind: 'enum', T: proto3.getEnumType(AttributeRuleTypeEnum) },
    { no: 5, name: 'values', kind: 'message', T: Value, repeated: true },
    { no: 6, name: 'grants', kind: 'message', T: KeyAccessServer, repeated: true },
    { no: 7, name: 'fqn', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 8, name: 'active', kind: 'message', T: BoolValue },
    { no: 100, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attribute {
    return new Attribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attribute {
    return new Attribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attribute {
    return new Attribute().fromJsonString(jsonString, options);
  }

  static equals(
    a: Attribute | PlainMessage<Attribute> | undefined,
    b: Attribute | PlainMessage<Attribute> | undefined
  ): boolean {
    return proto3.util.equals(Attribute, a, b);
  }
}

/**
 * @generated from message policy.Value
 */
export class Value extends Message<Value> {
  /**
   * generated uuid in database
   *
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * @generated from field: policy.Attribute attribute = 2;
   */
  attribute?: Attribute;

  /**
   * @generated from field: string value = 3;
   */
  value = '';

  /**
   * list of attribute values that this value is related to (attribute group)
   *
   * @generated from field: repeated policy.Value members = 4;
   */
  members: Value[] = [];

  /**
   * list of key access servers
   *
   * @generated from field: repeated policy.KeyAccessServer grants = 5;
   */
  grants: KeyAccessServer[] = [];

  /**
   * @generated from field: string fqn = 6;
   */
  fqn = '';

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 7;
   */
  active?: boolean;

  /**
   * subject mapping
   *
   * @generated from field: repeated policy.SubjectMapping subject_mappings = 8;
   */
  subjectMappings: SubjectMapping[] = [];

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.Value';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'attribute', kind: 'message', T: Attribute },
    { no: 3, name: 'value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 4, name: 'members', kind: 'message', T: Value, repeated: true },
    { no: 5, name: 'grants', kind: 'message', T: KeyAccessServer, repeated: true },
    { no: 6, name: 'fqn', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 7, name: 'active', kind: 'message', T: BoolValue },
    { no: 8, name: 'subject_mappings', kind: 'message', T: SubjectMapping, repeated: true },
    { no: 100, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(
    a: Value | PlainMessage<Value> | undefined,
    b: Value | PlainMessage<Value> | undefined
  ): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * An action an entity can take
 *
 * @generated from message policy.Action
 */
export class Action extends Message<Action> {
  /**
   * @generated from oneof policy.Action.value
   */
  value:
    | {
        /**
         * @generated from field: policy.Action.StandardAction standard = 1;
         */
        value: Action_StandardAction;
        case: 'standard';
      }
    | {
        /**
         * @generated from field: string custom = 2;
         */
        value: string;
        case: 'custom';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.Action';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'standard',
      kind: 'enum',
      T: proto3.getEnumType(Action_StandardAction),
      oneof: 'value',
    },
    { no: 2, name: 'custom', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'value' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(
    a: Action | PlainMessage<Action> | undefined,
    b: Action | PlainMessage<Action> | undefined
  ): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * Standard actions supported by the platform
 *
 * @generated from enum policy.Action.StandardAction
 */
export enum Action_StandardAction {
  /**
   * @generated from enum value: STANDARD_ACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STANDARD_ACTION_DECRYPT = 1;
   */
  DECRYPT = 1,

  /**
   * @generated from enum value: STANDARD_ACTION_TRANSMIT = 2;
   */
  TRANSMIT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Action_StandardAction)
proto3.util.setEnumType(Action_StandardAction, 'policy.Action.StandardAction', [
  { no: 0, name: 'STANDARD_ACTION_UNSPECIFIED' },
  { no: 1, name: 'STANDARD_ACTION_DECRYPT' },
  { no: 2, name: 'STANDARD_ACTION_TRANSMIT' },
]);

/**
 *
 * Subject Mapping: A Policy assigning Subject Set(s) to a permitted attribute value + action(s) combination
 *
 * Example: Subjects in sets 1 and 2 are entitled attribute value http://wwww.example.org/attr/example/value/one
 * with permitted actions TRANSMIT and DECRYPT
 * {
 * "id": "someid",
 * "attribute_value": {example_one_attribute_value...},
 * "subject_condition_set": {"subject_sets":[{subject_set_1},{subject_set_2}]...},
 * "actions": [{"standard": "STANDARD_ACTION_DECRYPT"}", {"standard": "STANDARD_ACTION_TRANSMIT"}]
 * }
 *
 * @generated from message policy.SubjectMapping
 */
export class SubjectMapping extends Message<SubjectMapping> {
  /**
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * the Attribute Value mapped to; aka: "The Entity Entitlement Attribute"
   *
   * @generated from field: policy.Value attribute_value = 2;
   */
  attributeValue?: Value;

  /**
   * the reusable SubjectConditionSet mapped to the given Attribute Value
   *
   * @generated from field: policy.SubjectConditionSet subject_condition_set = 3;
   */
  subjectConditionSet?: SubjectConditionSet;

  /**
   * The actions permitted by subjects in this mapping
   *
   * @generated from field: repeated policy.Action actions = 4;
   */
  actions: Action[] = [];

  /**
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<SubjectMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.SubjectMapping';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'attribute_value', kind: 'message', T: Value },
    { no: 3, name: 'subject_condition_set', kind: 'message', T: SubjectConditionSet },
    { no: 4, name: 'actions', kind: 'message', T: Action, repeated: true },
    { no: 100, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectMapping {
    return new SubjectMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectMapping {
    return new SubjectMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectMapping {
    return new SubjectMapping().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubjectMapping | PlainMessage<SubjectMapping> | undefined,
    b: SubjectMapping | PlainMessage<SubjectMapping> | undefined
  ): boolean {
    return proto3.util.equals(SubjectMapping, a, b);
  }
}

/**
 * *
 * A Condition defines a rule of <the value at the flattened 'selector value' location> <operator> <subject external values>
 *
 * Example:  Subjects with a field selected by the flattened selector "'.division'" and a value of "Accounting" or "Marketing":
 * {
 * "subject_external_selector_value": "'.division'",
 * "operator": "SUBJECT_MAPPING_OPERATOR_ENUM_IN",
 * "subject_external_values" : ["Accounting", "Marketing"]
 * }
 *
 * Example: Subjects that are not part of the Fantastic Four according to their alias field:
 * {
 * "subject_external_selector_value": "'.data[0].alias'",
 * "operator": "SUBJECT_MAPPING_OPERATOR_ENUM_NOT_IN",
 * "subject_external_values" : ["mister_fantastic", "the_thing", "human_torch", "invisible_woman"]
 * }
 *
 * @generated from message policy.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * a selector for a field value on a flattened Entity Representation (such as from idP/LDAP)
   *
   * @generated from field: string subject_external_selector_value = 1;
   */
  subjectExternalSelectorValue = '';

  /**
   * the evaluation operator of relation
   *
   * @generated from field: policy.SubjectMappingOperatorEnum operator = 2;
   */
  operator = SubjectMappingOperatorEnum.UNSPECIFIED;

  /**
   * list of comparison values for the result of applying the subject_external_selector_value on a flattened Entity Representation (Subject), evaluated by the operator
   *
   * @generated from field: repeated string subject_external_values = 3;
   */
  subjectExternalValues: string[] = [];

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.Condition';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'subject_external_selector_value',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
    },
    { no: 2, name: 'operator', kind: 'enum', T: proto3.getEnumType(SubjectMappingOperatorEnum) },
    {
      no: 3,
      name: 'subject_external_values',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(
    a: Condition | PlainMessage<Condition> | undefined,
    b: Condition | PlainMessage<Condition> | undefined
  ): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

/**
 * A collection of Conditions evaluated by the boolean_operator provided
 *
 * @generated from message policy.ConditionGroup
 */
export class ConditionGroup extends Message<ConditionGroup> {
  /**
   * @generated from field: repeated policy.Condition conditions = 1;
   */
  conditions: Condition[] = [];

  /**
   * the boolean evaluation type across the conditions
   *
   * @generated from field: policy.ConditionBooleanTypeEnum boolean_operator = 2;
   */
  booleanOperator = ConditionBooleanTypeEnum.UNSPECIFIED;

  constructor(data?: PartialMessage<ConditionGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.ConditionGroup';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'conditions', kind: 'message', T: Condition, repeated: true },
    {
      no: 2,
      name: 'boolean_operator',
      kind: 'enum',
      T: proto3.getEnumType(ConditionBooleanTypeEnum),
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConditionGroup {
    return new ConditionGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConditionGroup {
    return new ConditionGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConditionGroup {
    return new ConditionGroup().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConditionGroup | PlainMessage<ConditionGroup> | undefined,
    b: ConditionGroup | PlainMessage<ConditionGroup> | undefined
  ): boolean {
    return proto3.util.equals(ConditionGroup, a, b);
  }
}

/**
 * A collection of Condition Groups
 *
 * @generated from message policy.SubjectSet
 */
export class SubjectSet extends Message<SubjectSet> {
  /**
   * multiple Condition Groups are evaluated with AND logic
   *
   * @generated from field: repeated policy.ConditionGroup condition_groups = 1;
   */
  conditionGroups: ConditionGroup[] = [];

  constructor(data?: PartialMessage<SubjectSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.SubjectSet';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'condition_groups', kind: 'message', T: ConditionGroup, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectSet {
    return new SubjectSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectSet {
    return new SubjectSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectSet {
    return new SubjectSet().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubjectSet | PlainMessage<SubjectSet> | undefined,
    b: SubjectSet | PlainMessage<SubjectSet> | undefined
  ): boolean {
    return proto3.util.equals(SubjectSet, a, b);
  }
}

/**
 *
 * A container for multiple Subject Sets, each containing Condition Groups, each containing Conditions. Multiple Subject Sets in a SubjectConditionSet
 * are evaluated with AND logic. As each Subject Mapping has only one Attribute Value, the SubjectConditionSet is reusable across multiple
 * Subject Mappings / Attribute Values and is an independent unit.
 *
 * @generated from message policy.SubjectConditionSet
 */
export class SubjectConditionSet extends Message<SubjectConditionSet> {
  /**
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * @generated from field: repeated policy.SubjectSet subject_sets = 3;
   */
  subjectSets: SubjectSet[] = [];

  /**
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<SubjectConditionSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.SubjectConditionSet';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'subject_sets', kind: 'message', T: SubjectSet, repeated: true },
    { no: 100, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectConditionSet {
    return new SubjectConditionSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectConditionSet {
    return new SubjectConditionSet().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SubjectConditionSet {
    return new SubjectConditionSet().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubjectConditionSet | PlainMessage<SubjectConditionSet> | undefined,
    b: SubjectConditionSet | PlainMessage<SubjectConditionSet> | undefined
  ): boolean {
    return proto3.util.equals(SubjectConditionSet, a, b);
  }
}

/**
 *
 *
 * A property of a Subject/Entity as its selector expression -> value result pair. This would mirror external user attributes retrieved
 * from an authoritative source such as an IDP (Identity Provider) or User Store. Examples include such ADFS/LDAP, OKTA, etc.
 * For now, a valid property must contain both a selector expression & a resulting value.
 *
 * The external_selector_value is a specifier to select a value from a flattened external representation of an Entity (such as from idP/LDAP),
 * and the external_value is the value selected by the external_selector_value on that Entity Representation (Subject Context). These mirror the Condition.
 *
 * @generated from message policy.SubjectProperty
 */
export class SubjectProperty extends Message<SubjectProperty> {
  /**
   * @generated from field: string external_selector_value = 1;
   */
  externalSelectorValue = '';

  /**
   * @generated from field: string external_value = 2;
   */
  externalValue = '';

  constructor(data?: PartialMessage<SubjectProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.SubjectProperty';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'external_selector_value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'external_value', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectProperty {
    return new SubjectProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectProperty {
    return new SubjectProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectProperty {
    return new SubjectProperty().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubjectProperty | PlainMessage<SubjectProperty> | undefined,
    b: SubjectProperty | PlainMessage<SubjectProperty> | undefined
  ): boolean {
    return proto3.util.equals(SubjectProperty, a, b);
  }
}

/**
 *
 * Resource Mappings (aka Access Control Resource Encodings aka ACRE) are structures supporting the mapping of Resources and Attribute Values
 *
 * @generated from message policy.ResourceMapping
 */
export class ResourceMapping extends Message<ResourceMapping> {
  /**
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * @generated from field: common.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * @generated from field: policy.Value attribute_value = 3;
   */
  attributeValue?: Value;

  /**
   * @generated from field: repeated string terms = 4;
   */
  terms: string[] = [];

  constructor(data?: PartialMessage<ResourceMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.ResourceMapping';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'metadata', kind: 'message', T: Metadata },
    { no: 3, name: 'attribute_value', kind: 'message', T: Value },
    { no: 4, name: 'terms', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMapping {
    return new ResourceMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMapping {
    return new ResourceMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMapping {
    return new ResourceMapping().fromJsonString(jsonString, options);
  }

  static equals(
    a: ResourceMapping | PlainMessage<ResourceMapping> | undefined,
    b: ResourceMapping | PlainMessage<ResourceMapping> | undefined
  ): boolean {
    return proto3.util.equals(ResourceMapping, a, b);
  }
}

/**
 *
 * Key Access Server Registry
 *
 * @generated from message policy.KeyAccessServer
 */
export class KeyAccessServer extends Message<KeyAccessServer> {
  /**
   * @generated from field: string id = 1;
   */
  id = '';

  /**
   * Address of a KAS instance
   *
   * @generated from field: string uri = 2;
   */
  uri = '';

  /**
   * @generated from field: policy.PublicKey public_key = 3;
   */
  publicKey?: PublicKey;

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<KeyAccessServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.KeyAccessServer';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'uri', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 3, name: 'public_key', kind: 'message', T: PublicKey },
    { no: 100, name: 'metadata', kind: 'message', T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyAccessServer {
    return new KeyAccessServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyAccessServer {
    return new KeyAccessServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyAccessServer {
    return new KeyAccessServer().fromJsonString(jsonString, options);
  }

  static equals(
    a: KeyAccessServer | PlainMessage<KeyAccessServer> | undefined,
    b: KeyAccessServer | PlainMessage<KeyAccessServer> | undefined
  ): boolean {
    return proto3.util.equals(KeyAccessServer, a, b);
  }
}

/**
 * @generated from message policy.PublicKey
 */
export class PublicKey extends Message<PublicKey> {
  /**
   * @generated from oneof policy.PublicKey.public_key
   */
  publicKey:
    | {
        /**
         * kas public key url - optional since can also be retrieved via public key
         *
         * @generated from field: string remote = 1;
         */
        value: string;
        case: 'remote';
      }
    | {
        /**
         * public key - optional since can also be retrieved via url
         *
         * @generated from field: string local = 2;
         */
        value: string;
        case: 'local';
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PublicKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'policy.PublicKey';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'remote', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'public_key' },
    { no: 2, name: 'local', kind: 'scalar', T: 9 /* ScalarType.STRING */, oneof: 'public_key' },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey {
    return new PublicKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: PublicKey | PlainMessage<PublicKey> | undefined,
    b: PublicKey | PlainMessage<PublicKey> | undefined
  ): boolean {
    return proto3.util.equals(PublicKey, a, b);
  }
}
