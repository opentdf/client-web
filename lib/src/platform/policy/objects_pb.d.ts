// @generated by protoc-gen-es v1.9.0 with parameter "target=js+dts,import_extension=none"
// @generated from file policy/objects.proto (package policy, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Metadata } from "../common/common_pb";

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.AttributeRuleTypeEnum
 */
export declare enum AttributeRuleTypeEnum {
  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_ALL_OF = 1;
   */
  ALL_OF = 1,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF = 2;
   */
  ANY_OF = 2,

  /**
   * @generated from enum value: ATTRIBUTE_RULE_TYPE_ENUM_HIERARCHY = 3;
   */
  HIERARCHY = 3,
}

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.SubjectMappingOperatorEnum
 */
export declare enum SubjectMappingOperatorEnum {
  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_IN = 1;
   */
  IN = 1,

  /**
   * @generated from enum value: SUBJECT_MAPPING_OPERATOR_ENUM_NOT_IN = 2;
   */
  NOT_IN = 2,
}

/**
 * buflint ENUM_VALUE_PREFIX: to make sure that C++ scoping rules aren't violated when users add new enum values to an enum in a given package
 *
 * @generated from enum policy.ConditionBooleanTypeEnum
 */
export declare enum ConditionBooleanTypeEnum {
  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_AND = 1;
   */
  AND = 1,

  /**
   * @generated from enum value: CONDITION_BOOLEAN_TYPE_ENUM_OR = 2;
   */
  OR = 2,
}

/**
 * @generated from message policy.Namespace
 */
export declare class Namespace extends Message<Namespace> {
  /**
   * generated uuid in database
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * used to partition Attribute Definitions, support by namespace AuthN and enable federation
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: string fqn = 3;
   */
  fqn: string;

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 4;
   */
  active?: boolean;

  /**
   * @generated from field: common.Metadata metadata = 5;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Namespace>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.Namespace";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Namespace;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Namespace;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Namespace;

  static equals(a: Namespace | PlainMessage<Namespace> | undefined, b: Namespace | PlainMessage<Namespace> | undefined): boolean;
}

/**
 * @generated from message policy.Attribute
 */
export declare class Attribute extends Message<Attribute> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * namespace of the attribute
   *
   * @generated from field: policy.Namespace namespace = 2;
   */
  namespace?: Namespace;

  /**
   * attribute name
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * attribute rule enum
   *
   * @generated from field: policy.AttributeRuleTypeEnum rule = 4;
   */
  rule: AttributeRuleTypeEnum;

  /**
   * @generated from field: repeated policy.Value values = 5;
   */
  values: Value[];

  /**
   * @generated from field: repeated policy.KeyAccessServer grants = 6;
   */
  grants: KeyAccessServer[];

  /**
   * @generated from field: string fqn = 7;
   */
  fqn: string;

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 8;
   */
  active?: boolean;

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Attribute>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.Attribute";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attribute;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attribute;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attribute;

  static equals(a: Attribute | PlainMessage<Attribute> | undefined, b: Attribute | PlainMessage<Attribute> | undefined): boolean;
}

/**
 * @generated from message policy.Value
 */
export declare class Value extends Message<Value> {
  /**
   * generated uuid in database
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: policy.Attribute attribute = 2;
   */
  attribute?: Attribute;

  /**
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * list of attribute values that this value is related to (attribute group)
   *
   * @generated from field: repeated policy.Value members = 4;
   */
  members: Value[];

  /**
   * list of key access servers
   *
   * @generated from field: repeated policy.KeyAccessServer grants = 5;
   */
  grants: KeyAccessServer[];

  /**
   * @generated from field: string fqn = 6;
   */
  fqn: string;

  /**
   * active by default until explicitly deactivated
   *
   * @generated from field: google.protobuf.BoolValue active = 7;
   */
  active?: boolean;

  /**
   * subject mapping
   *
   * @generated from field: repeated policy.SubjectMapping subject_mappings = 8;
   */
  subjectMappings: SubjectMapping[];

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<Value>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.Value";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value;

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean;
}

/**
 * An action an entity can take
 *
 * @generated from message policy.Action
 */
export declare class Action extends Message<Action> {
  /**
   * @generated from oneof policy.Action.value
   */
  value: {
    /**
     * @generated from field: policy.Action.StandardAction standard = 1;
     */
    value: Action_StandardAction;
    case: "standard";
  } | {
    /**
     * @generated from field: string custom = 2;
     */
    value: string;
    case: "custom";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Action>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.Action";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action;

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean;
}

/**
 * Standard actions supported by the platform
 *
 * @generated from enum policy.Action.StandardAction
 */
export declare enum Action_StandardAction {
  /**
   * @generated from enum value: STANDARD_ACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STANDARD_ACTION_DECRYPT = 1;
   */
  DECRYPT = 1,

  /**
   * @generated from enum value: STANDARD_ACTION_TRANSMIT = 2;
   */
  TRANSMIT = 2,
}

/**
 *
 * Subject Mapping: A Policy assigning Subject Set(s) to a permitted attribute value + action(s) combination
 *
 * Example: Subjects in sets 1 and 2 are entitled attribute value http://wwww.example.org/attr/example/value/one
 * with permitted actions TRANSMIT and DECRYPT
 * {
 * "id": "someid",
 * "attribute_value": {example_one_attribute_value...},
 * "subject_condition_set": {"subject_sets":[{subject_set_1},{subject_set_2}]...},
 * "actions": [{"standard": "STANDARD_ACTION_DECRYPT"}", {"standard": "STANDARD_ACTION_TRANSMIT"}]
 * }
 *
 * @generated from message policy.SubjectMapping
 */
export declare class SubjectMapping extends Message<SubjectMapping> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * the Attribute Value mapped to; aka: "The Entity Entitlement Attribute"
   *
   * @generated from field: policy.Value attribute_value = 2;
   */
  attributeValue?: Value;

  /**
   * the reusable SubjectConditionSet mapped to the given Attribute Value
   *
   * @generated from field: policy.SubjectConditionSet subject_condition_set = 3;
   */
  subjectConditionSet?: SubjectConditionSet;

  /**
   * The actions permitted by subjects in this mapping
   *
   * @generated from field: repeated policy.Action actions = 4;
   */
  actions: Action[];

  /**
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<SubjectMapping>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.SubjectMapping";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectMapping;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectMapping;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectMapping;

  static equals(a: SubjectMapping | PlainMessage<SubjectMapping> | undefined, b: SubjectMapping | PlainMessage<SubjectMapping> | undefined): boolean;
}

/**
 * *
 * A Condition defines a rule of <the value at the flattened 'selector value' location> <operator> <subject external values>
 *
 * Example:  Subjects with a field selected by the flattened selector "'.division'" and a value of "Accounting" or "Marketing":
 * {
 * "subject_external_selector_value": "'.division'",
 * "operator": "SUBJECT_MAPPING_OPERATOR_ENUM_IN",
 * "subject_external_values" : ["Accounting", "Marketing"]
 * }
 *
 * Example: Subjects that are not part of the Fantastic Four according to their alias field:
 * {
 * "subject_external_selector_value": "'.data[0].alias'",
 * "operator": "SUBJECT_MAPPING_OPERATOR_ENUM_NOT_IN",
 * "subject_external_values" : ["mister_fantastic", "the_thing", "human_torch", "invisible_woman"]
 * }
 *
 * @generated from message policy.Condition
 */
export declare class Condition extends Message<Condition> {
  /**
   * a selector for a field value on a flattened Entity Representation (such as from idP/LDAP)
   *
   * @generated from field: string subject_external_selector_value = 1;
   */
  subjectExternalSelectorValue: string;

  /**
   * the evaluation operator of relation
   *
   * @generated from field: policy.SubjectMappingOperatorEnum operator = 2;
   */
  operator: SubjectMappingOperatorEnum;

  /**
   * list of comparison values for the result of applying the subject_external_selector_value on a flattened Entity Representation (Subject), evaluated by the operator
   *
   * @generated from field: repeated string subject_external_values = 3;
   */
  subjectExternalValues: string[];

  constructor(data?: PartialMessage<Condition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.Condition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition;

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean;
}

/**
 * A collection of Conditions evaluated by the boolean_operator provided
 *
 * @generated from message policy.ConditionGroup
 */
export declare class ConditionGroup extends Message<ConditionGroup> {
  /**
   * @generated from field: repeated policy.Condition conditions = 1;
   */
  conditions: Condition[];

  /**
   * the boolean evaluation type across the conditions
   *
   * @generated from field: policy.ConditionBooleanTypeEnum boolean_operator = 2;
   */
  booleanOperator: ConditionBooleanTypeEnum;

  constructor(data?: PartialMessage<ConditionGroup>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.ConditionGroup";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConditionGroup;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConditionGroup;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConditionGroup;

  static equals(a: ConditionGroup | PlainMessage<ConditionGroup> | undefined, b: ConditionGroup | PlainMessage<ConditionGroup> | undefined): boolean;
}

/**
 * A collection of Condition Groups
 *
 * @generated from message policy.SubjectSet
 */
export declare class SubjectSet extends Message<SubjectSet> {
  /**
   * multiple Condition Groups are evaluated with AND logic
   *
   * @generated from field: repeated policy.ConditionGroup condition_groups = 1;
   */
  conditionGroups: ConditionGroup[];

  constructor(data?: PartialMessage<SubjectSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.SubjectSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectSet;

  static equals(a: SubjectSet | PlainMessage<SubjectSet> | undefined, b: SubjectSet | PlainMessage<SubjectSet> | undefined): boolean;
}

/**
 *
 * A container for multiple Subject Sets, each containing Condition Groups, each containing Conditions. Multiple Subject Sets in a SubjectConditionSet
 * are evaluated with AND logic. As each Subject Mapping has only one Attribute Value, the SubjectConditionSet is reusable across multiple
 * Subject Mappings / Attribute Values and is an independent unit.
 *
 * @generated from message policy.SubjectConditionSet
 */
export declare class SubjectConditionSet extends Message<SubjectConditionSet> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: repeated policy.SubjectSet subject_sets = 3;
   */
  subjectSets: SubjectSet[];

  /**
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<SubjectConditionSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.SubjectConditionSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectConditionSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectConditionSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectConditionSet;

  static equals(a: SubjectConditionSet | PlainMessage<SubjectConditionSet> | undefined, b: SubjectConditionSet | PlainMessage<SubjectConditionSet> | undefined): boolean;
}

/**
 *
 *
 * A property of a Subject/Entity as its selector expression -> value result pair. This would mirror external user attributes retrieved
 * from an authoritative source such as an IDP (Identity Provider) or User Store. Examples include such ADFS/LDAP, OKTA, etc.
 * For now, a valid property must contain both a selector expression & a resulting value.
 *
 * The external_selector_value is a specifier to select a value from a flattened external representation of an Entity (such as from idP/LDAP),
 * and the external_value is the value selected by the external_selector_value on that Entity Representation (Subject Context). These mirror the Condition.
 *
 * @generated from message policy.SubjectProperty
 */
export declare class SubjectProperty extends Message<SubjectProperty> {
  /**
   * @generated from field: string external_selector_value = 1;
   */
  externalSelectorValue: string;

  /**
   * @generated from field: string external_value = 2;
   */
  externalValue: string;

  constructor(data?: PartialMessage<SubjectProperty>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.SubjectProperty";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectProperty;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectProperty;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectProperty;

  static equals(a: SubjectProperty | PlainMessage<SubjectProperty> | undefined, b: SubjectProperty | PlainMessage<SubjectProperty> | undefined): boolean;
}

/**
 *
 * Resource Mappings (aka Access Control Resource Encodings aka ACRE) are structures supporting the mapping of Resources and Attribute Values
 *
 * @generated from message policy.ResourceMapping
 */
export declare class ResourceMapping extends Message<ResourceMapping> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: common.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * @generated from field: policy.Value attribute_value = 3;
   */
  attributeValue?: Value;

  /**
   * @generated from field: repeated string terms = 4;
   */
  terms: string[];

  constructor(data?: PartialMessage<ResourceMapping>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.ResourceMapping";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMapping;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMapping;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMapping;

  static equals(a: ResourceMapping | PlainMessage<ResourceMapping> | undefined, b: ResourceMapping | PlainMessage<ResourceMapping> | undefined): boolean;
}

/**
 *
 * Key Access Server Registry
 *
 * @generated from message policy.KeyAccessServer
 */
export declare class KeyAccessServer extends Message<KeyAccessServer> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Address of a KAS instance
   *
   * @generated from field: string uri = 2;
   */
  uri: string;

  /**
   * @generated from field: policy.PublicKey public_key = 3;
   */
  publicKey?: PublicKey;

  /**
   * Common metadata
   *
   * @generated from field: common.Metadata metadata = 100;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<KeyAccessServer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.KeyAccessServer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyAccessServer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyAccessServer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyAccessServer;

  static equals(a: KeyAccessServer | PlainMessage<KeyAccessServer> | undefined, b: KeyAccessServer | PlainMessage<KeyAccessServer> | undefined): boolean;
}

/**
 * @generated from message policy.PublicKey
 */
export declare class PublicKey extends Message<PublicKey> {
  /**
   * @generated from oneof policy.PublicKey.public_key
   */
  publicKey: {
    /**
     * kas public key url - optional since can also be retrieved via public key
     *
     * @generated from field: string remote = 1;
     */
    value: string;
    case: "remote";
  } | {
    /**
     * public key - optional since can also be retrieved via url
     *
     * @generated from field: string local = 2;
     */
    value: string;
    case: "local";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<PublicKey>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "policy.PublicKey";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey;

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean;
}

